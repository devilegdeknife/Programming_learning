var searchIndex = JSON.parse('{\
"ferris_says":{"doc":"","t":"F","n":["say"],"q":[[0,"ferris_says"],[1,"std::io::error"],[2,"std::io"]],"d":["Print out Ferris saying something."],"i":[0],"f":[[[1,2,-1],[[4,[3]]],5]],"c":[],"p":[[15,"str"],[15,"usize"],[15,"tuple"],[6,"Result",1],[8,"Write",2]]},\
"hello_rust":{"doc":"","t":"F","n":["main"],"q":[[0,"hello_rust"]],"d":[""],"i":[0],"f":[[[],1]],"c":[],"p":[[15,"tuple"]]},\
"smallvec":{"doc":"Small vectors in various sizes. These store a certain …","t":"NINEDDQDILLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLOLLLLKLLLLLLLLLLLLLLLLLLM","n":["AllocErr","Array","CapacityOverflow","CollectionAllocErr","Drain","IntoIter","Item","SmallVec","ToSmallVec","append","as_mut","as_mut_ptr","as_mut_slice","as_mut_slice","as_ptr","as_ref","as_slice","as_slice","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","capacity","clear","clone","clone","clone_from","clone_into","clone_into","cmp","dedup","dedup_by","dedup_by_key","default","deref","deref_mut","drain","drop","drop","drop","eq","extend","extend_from_slice","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from_buf","from_buf_and_len","from_buf_and_len_unchecked","from_elem","from_iter","from_raw_parts","from_slice","from_vec","grow","hash","index","index_mut","inline_size","insert","insert_from_slice","insert_many","into","into","into","into","into_boxed_slice","into_inner","into_iter","into_iter","into_iter","into_iter","into_iter","into_vec","is_empty","len","len","new","next","next","next_back","next_back","partial_cmp","pop","push","remove","reserve","reserve_exact","resize","resize_with","retain","retain_mut","set_len","shrink_to_fit","size","size_hint","size_hint","smallvec","spilled","swap_remove","to_owned","to_owned","to_smallvec","to_string","truncate","try_from","try_from","try_from","try_from","try_grow","try_into","try_into","try_into","try_into","try_reserve","try_reserve_exact","type_id","type_id","type_id","type_id","with_capacity","layout"],"q":[[0,"smallvec"],[138,"smallvec::CollectionAllocErr"],[139,"core::clone"],[140,"core::cmp"],[141,"core::ops::function"],[142,"core::ops::range"],[143,"core::iter::traits::collect"],[144,"core::fmt"],[145,"core::fmt"],[146,"core::alloc::layout"],[147,"core::mem::maybe_uninit"],[148,"core::hash"],[149,"core::slice::index"],[150,"alloc::boxed"],[151,"core::result"],[152,"core::option"],[153,"alloc::string"],[154,"core::any"]],"d":["The allocator return an error","Types that can be used as the backing store for a <code>SmallVec</code>.","Overflow <code>usize::MAX</code> or other error during size computation","Error type for APIs with fallible heap allocation","An iterator that removes the items from a <code>SmallVec</code> and …","An iterator that consumes a <code>SmallVec</code> and yields its items …","The type of the array’s elements.","A <code>Vec</code>-like container that can store a small number of …","Convenience trait for constructing a <code>SmallVec</code>","Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> …","","Returns a raw mutable pointer to the vector’s buffer.","Extracts a mutable slice of the entire vector.","Returns the remaining items of this iterator as a mutable …","Returns a raw pointer to the vector’s buffer.","","Extracts a slice containing the entire vector.","Returns the remaining items of this iterator as a slice.","","","","","","","","","","","The number of items the vector can hold without …","Remove all elements from the vector.","","","","","","","Removes consecutive duplicate elements.","Removes consecutive duplicate elements using the given …","Removes consecutive elements that map to the same key.","","","","Creates a draining iterator that removes the specified …","","","","","","Copy elements from a slice and append them to the vector.","","","","","","Returns the argument unchanged.","","","","Returns the argument unchanged.","","Returns the argument unchanged.","","Returns the argument unchanged.","Constructs a new <code>SmallVec</code> on the stack from an <code>A</code> without …","Constructs a new <code>SmallVec</code> on the stack from an <code>A</code> without …","Constructs a new <code>SmallVec</code> on the stack from an <code>A</code> without …","Creates a <code>SmallVec</code> with <code>n</code> copies of <code>elem</code>.","","Creates a <code>SmallVec</code> directly from the raw components of …","Copy the elements from a slice into a new <code>SmallVec</code>.","Construct a new <code>SmallVec</code> from a <code>Vec&lt;A::Item&gt;</code>.","Re-allocate to set the capacity to …","","","","The maximum number of elements this vector can hold inline","Insert an element at position <code>index</code>, shifting all elements …","Copy elements from a slice into the vector at position …","Insert multiple elements at position <code>index</code>, shifting all …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Converts a <code>SmallVec</code> into a <code>Box&lt;[T]&gt;</code> without reallocating …","Convert the <code>SmallVec</code> into an <code>A</code> if possible. Otherwise …","","","","","","Convert a <code>SmallVec</code> to a <code>Vec</code>, without reallocating if the …","Returns <code>true</code> if the vector is empty","","The number of elements stored in the vector","Construct an empty vector","","","","","","Remove an item from the end of the vector and return it, …","Append an item to the vector.","Remove and return the element at position <code>index</code>, shifting …","Reserve capacity for <code>additional</code> more elements to be …","Reserve the minimum capacity for <code>additional</code> more elements …","Resizes the vector so that its length is equal to <code>len</code>.","Resizes the <code>SmallVec</code> in-place so that <code>len</code> is equal to …","Retains only the elements specified by the predicate.","Retains only the elements specified by the predicate.","Sets the length of a vector.","Shrink the capacity of the vector as much as possible.","Returns the number of items the array can hold.","","","Creates a <code>SmallVec</code> containing the arguments.","Returns <code>true</code> if the data has spilled into a separate …","Remove the element at position <code>index</code>, replacing it with …","","","Construct a new <code>SmallVec</code> from a slice.","","Shorten the vector, keeping the first <code>len</code> elements and …","","","","","Re-allocate to set the capacity to …","","","","","Reserve capacity for <code>additional</code> more elements to be …","Reserve the minimum capacity for <code>additional</code> more elements …","","","","","Construct an empty vector with enough capacity …","The layout that was passed to the allocator"],"i":[16,0,16,0,0,0,3,0,0,1,1,1,1,5,1,1,1,5,10,1,1,5,16,10,1,1,5,16,1,1,1,5,1,1,5,1,1,1,1,1,1,1,1,10,1,5,1,1,1,10,1,5,16,16,10,1,1,1,1,1,5,16,16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,10,1,5,16,1,1,10,1,1,1,5,1,1,10,1,1,10,5,10,5,1,1,1,1,1,1,1,1,1,1,1,1,3,10,5,0,1,1,1,5,28,16,1,10,1,5,16,1,10,1,5,16,1,1,10,1,5,16,1,29],"f":[0,0,0,0,0,0,0,0,0,[[[1,[-1]],[1,[-2]]],2,3,3],[[[1,[-1]]],4,3],[[[1,[-1]]],[],3],[[[1,[-1]]],4,3],[[[5,[-1]]],4,3],[[[1,[-1]]],[],3],[[[1,[-1]]],4,3],[[[1,[-1]]],4,3],[[[5,[-1]]],4,3],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],4,3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],4,3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],6,3],[[[1,[-1]]],2,3],[[[1,[-1]]],[[1,[-1]]],3],[[[5,[-1]]],[[5,[-1]]],[3,7]],[[[1,[-1]],[1,[-1]]],2,3],[[-1,-2],2,[],[]],[[-1,-2],2,[],[]],[[[1,[-1]],[1,[-1]]],8,3],[[[1,[-1]]],2,3],[[[1,[-1]],-2],2,3,9],[[[1,[-1]],-2],2,3,9],[[],[[1,[-1]]],3],[[[1,[-1]]],4,3],[[[1,[-1]]],4,3],[[[1,[-1]],-2],[[10,[-1]]],3,[[11,[6]]]],[[[10,[-1]]],2,3],[[[1,[-1]]],2,3],[[[5,[-1]]],2,3],[[[1,[-1]],[1,[-2]]],12,3,3],[[[1,[-1]],-2],2,3,13],[[[1,[-1]],4],2,3],[[[10,[-1]],14],15,3],[[[1,[-1]],14],15,3],[[[5,[-1]],14],15,3],[[16,14],15],[[16,14],15],[-1,-1,[]],[17,[[1,[-1]]],3],[18,-1,[]],[4,[[1,[-1]]],3],[-1,-1,[]],[-1,[[1,[-1]]],3],[-1,-1,[]],[19,16],[-1,-1,[]],[-1,[[1,[-1]]],3],[[-1,6],[[1,[-1]]],3],[[[20,[-1]],6],[[1,[-1]]],3],[6,[[1,[-1]]],3],[-1,[[1,[-2]]],13,3],[[6,6],[[1,[-1]]],3],[4,[[1,[-1]]],3],[17,[[1,[-1]]],3],[[[1,[-1]],6],2,3],[[[1,[-1]],-2],2,3,21],[[[1,[-1]],-2],[],3,[[22,[4]]]],[[[1,[-1]],-2],[],3,[[22,[4]]]],[[[1,[-1]]],6,3],[[[1,[-1]],6],2,3],[[[1,[-1]],6,4],2,3],[[[1,[-1]],6,-2],2,3,13],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[23,[4]]],3],[[[1,[-1]]],[[24,[-1,[1,[-1]]]]],3],[-1,-2,[],[]],[[[1,[-1]]],[],3],[[[1,[-1]]],[],3],[[[1,[-1]]],[],3],[-1,-2,[],[]],[[[1,[-1]]],17,3],[[[1,[-1]]],12,3],[[[10,[-1]]],6,3],[[[1,[-1]]],6,3],[[],[[1,[-1]]],3],[[[10,[-1]]],25,3],[[[5,[-1]]],25,3],[[[10,[-1]]],25,3],[[[5,[-1]]],25,3],[[[1,[-1]],[1,[-1]]],[[25,[8]]],3],[[[1,[-1]]],25,3],[[[1,[-1]]],2,3],[[[1,[-1]],6],[],3],[[[1,[-1]],6],2,3],[[[1,[-1]],6],2,3],[[[1,[-1]],6],2,3],[[[1,[-1]],6,-2],2,3,9],[[[1,[-1]],-2],2,3,9],[[[1,[-1]],-2],2,3,9],[[[1,[-1]],6],2,3],[[[1,[-1]]],2,3],[[],6],[[[10,[-1]]],[[2,[6,[25,[6]]]]],3],[[[5,[-1]]],[[2,[6,[25,[6]]]]],3],0,[[[1,[-1]]],12,3],[[[1,[-1]],6],[],3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[1,[-2]]],[],[]],[-1,26,[]],[[[1,[-1]],6],2,3],[-1,[[24,[-2]]],[],[]],[-1,[[24,[-2]]],[],[]],[-1,[[24,[-2]]],[],[]],[-1,[[24,[-2]]],[],[]],[[[1,[-1]],6],[[24,[2,16]]],3],[-1,[[24,[-2]]],[],[]],[-1,[[24,[-2]]],[],[]],[-1,[[24,[-2]]],[],[]],[-1,[[24,[-2]]],[],[]],[[[1,[-1]],6],[[24,[2,16]]],3],[[[1,[-1]],6],[[24,[2,16]]],3],[-1,27,[]],[-1,27,[]],[-1,27,[]],[-1,27,[]],[6,[[1,[-1]]],3],0],"c":[],"p":[[3,"SmallVec",0],[15,"tuple"],[8,"Array",0],[15,"slice"],[3,"IntoIter",0],[15,"usize"],[8,"Clone",139],[4,"Ordering",140],[8,"FnMut",141],[3,"Drain",0],[8,"RangeBounds",142],[15,"bool"],[8,"IntoIterator",143],[3,"Formatter",144],[6,"Result",144],[4,"CollectionAllocErr",0],[3,"Vec",145],[15,"never"],[6,"LayoutErr",146],[19,"MaybeUninit",147],[8,"Hasher",148],[8,"SliceIndex",149],[3,"Box",150],[4,"Result",151],[4,"Option",152],[3,"String",153],[3,"TypeId",154],[8,"ToSmallVec",0],[13,"AllocErr",138]]},\
"smawk":{"doc":"This crate implements various functions that help speed up …","t":"IFKAKKFFFFF","n":["Matrix","column_minima","index","monge","ncols","nrows","online_column_minima","row_minima","smawk_column_minima","smawk_row_minima","is_monge"],"q":[[0,"smawk"],[10,"smawk::monge"],[11,"alloc::vec"],[12,"core::cmp"],[13,"core::marker"],[14,"core::ops::function"],[15,"core::cmp"]],"d":["Minimal matrix trait for two-dimensional arrays.","Compute column minima in O(<em>m</em> + <em>n</em>) time.","Return a matrix element.","Functions for generating and checking Monge arrays.","Return the number of columns.","Return the number of rows.","Compute upper-right column minima in O(<em>m</em> + <em>n</em>) time.","Compute row minima in O(<em>m</em> + <em>n</em>) time.","","","Verify that a matrix is a Monge matrix."],"i":[0,0,5,0,5,5,0,0,0,0,0],"f":[0,[-2,[[2,[1]]],[3,4],[[5,[-1]]]],[[-1,1,1],-2,[],[]],0,[-1,1,[]],[-1,1,[]],[[-1,1,-2],[[2,[[6,[1,-1]]]]],[4,3],7],[-2,[[2,[1]]],[3,4],[[5,[-1]]]],[-2,[[2,[1]]],[3,4],[[5,[-1]]]],[-2,[[2,[1]]],[3,4],[[5,[-1]]]],[-2,8,[9,4],[[5,[-1]]]]],"c":[8,9],"p":[[15,"usize"],[3,"Vec",11],[8,"PartialOrd",12],[8,"Copy",13],[8,"Matrix",0],[15,"tuple"],[8,"Fn",14],[15,"bool"],[8,"Ord",12]]},\
"textwrap":{"doc":"The textwrap library provides functions for word wrapping …","t":"DDDILLLLLLLMLLLLLLAFFFLLLLLLLLFLMLLLLFKLLLMLMLLLLLLLLLLLLFMLFLMFNINDELLLLLFLLLLLFLLLLFLLLLLLLKLFLLLLLLLLKLKLFF","n":["HyphenSplitter","NoHyphenation","Options","WordSplitter","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","break_words","break_words","clone","clone","clone","clone_into","clone_into","clone_into","core","dedent","fill","fill_inplace","fmt","fmt","fmt","from","from","from","from","from","indent","initial_indent","initial_indent","into","into","into","new","refill","split_points","split_points","split_points","splitter","splitter","subsequent_indent","subsequent_indent","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","unfill","width","with_splitter","wrap","wrap_algorithm","wrap_algorithm","wrap_columns","FirstFit","Fragment","OptimalFit","Word","WrapAlgorithm","borrow","borrow","borrow_mut","borrow_mut","break_apart","break_words","clone","clone","clone_into","clone_into","deref","display_width","eq","eq","equivalent","equivalent","find_words","fmt","fmt","from","from","from","into","into","penalty_width","penalty_width","split_words","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","whitespace_width","whitespace_width","width","width","wrap_first_fit","wrap_optimal_fit"],"q":[[0,"textwrap"],[64,"textwrap::core"],[110,"core::clone"],[111,"core::marker"],[112,"alloc::string"],[113,"core::convert"],[114,"core::fmt"],[115,"core::fmt"],[116,"core::result"],[117,"core::any"],[118,"alloc::borrow"],[119,"core::iter::traits::iterator"],[120,"core::iter::traits::collect"],[121,"core::ops::function"]],"d":["Simple and default way to split words: splitting on …","Use this as a <code>Options.splitter</code> to avoid any kind of …","Holds settings for wrapping and filling text.","The <code>WordSplitter</code> trait describes where words can be split.","","","","","","","Change <code>self.break_words</code>. This controls if words longer …","Allow long words to be broken if they cannot fit on a line.","","","","","","","Building blocks for advanced wrapping functionality.","Removes common leading whitespace from each line.","Fill a line of text at a given width.","Fill <code>text</code> in-place without reallocating the input string.","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","Add prefix to each non-empty line.","Change <code>self.initial_indent</code>. The initial indentation is …","Indentation used for the first line of output. See the …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Creates a new <code>Options</code> with the specified width and static …","Refill a paragraph of wrapped text with a new width.","Return all possible indices where <code>word</code> can be split.","","","Change <code>self.splitter</code>. The <code>WordSplitter</code> is used to fit part …","The method for splitting words. This can be used to …","Change <code>self.subsequent_indent</code>. The subsequent indentation …","Indentation used for subsequent lines of output. See the …","","","","","","","","","","","","","Unpack a paragraph of already-wrapped text.","The width in columns at which the text will be wrapped.","Creates a new <code>Options</code> with the specified width and …","Wrap a line of text at a given width.","Change <code>self.wrap_algorithm</code>.","Wraping algorithm to use, see <code>core::WrapAlgorithm</code> for …","Wrap text into columns with a given total width.","Use a fast and simple algorithm with no look-ahead to find …","A (text) fragment denotes the unit which we wrap into …","Use an advanced algorithm which considers the entire …","A piece of wrappable text, including any trailing …","Wrapping algorithms.","","","","","Break this word into smaller words with a width of at most …","Forcibly break words wider than <code>line_width</code> into smaller …","","","","","","Compute the display width of <code>text</code> while skipping over ANSI …","","","","","Split line into words separated by regions of <code>&#39; &#39;</code> …","","","Construct a new <code>Word</code>.","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Displayed width of the penalty that must be inserted if the","","Split words into smaller words according to the split …","","","","","","","","","Displayed width of the whitespace that must follow the word","","Displayed width of word represented by this fragment.","","Wrap abstract fragments into lines with a first-fit …","Wrap abstract fragments into lines with an optimal-fit …"],"i":[0,0,0,0,4,5,1,4,5,1,1,1,4,5,1,4,5,1,0,0,0,0,4,5,1,4,5,1,1,1,0,1,1,4,5,1,1,0,3,4,5,1,1,1,1,4,5,1,4,5,1,4,5,1,4,5,1,0,1,1,0,1,1,0,20,0,20,0,0,21,20,21,20,21,0,21,20,21,20,21,0,21,20,21,20,0,21,20,21,21,20,21,20,25,21,0,21,20,21,20,21,20,21,20,25,21,25,21,0,0],"f":[0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]],2],[[1,[-1]]],3],0,[4,4],[5,5],[[[1,[-1]]],[[1,[-1]]],[6,7]],[[-1,-2],8,[],[]],[[-1,-2],8,[],[]],[[-1,-2],8,[],[]],0,[9,10],[[9,-2],10,3,[[11,[[1,[-1]]]]]],[[10,12],8],[[4,13],14],[[5,13],14],[[[1,[-1]],13],14,[15,7]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[[[1,[-1]]],[[1,[-1]]],7],[12,[[1,[5]]]],[[9,9],10],[[[1,[-1]],9],[[1,[-1]]],3],0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[12,[[1,[5]]]],[[9,-2],10,3,[[11,[[1,[-1]]]]]],[[-1,9],[[16,[12]]],[]],[[4,9],[[16,[12]]]],[[5,9],[[16,[12]]]],[[[1,[-1]],-2],[[1,[-2]]],3,[]],0,[[[1,[-1]],9],[[1,[-1]]],3],0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,18,[]],[-1,18,[]],[-1,18,[]],[9,[[8,[10,[1,[5]]]]]],0,[[12,-1],[[1,[-1]]],[]],[[9,-2],[[16,[[19,[9]]]]],3,[[11,[[1,[-1]]]]]],[[[1,[-1]],20],[[1,[-1]]],3],0,[[9,12,-2,9,9,9],[[16,[10]]],3,[[11,[[1,[-1]]]]]],0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[21,12],[[0,[22]]]],[[-1,12],[[16,[21]]],23],[21,21],[20,20],[[-1,-2],8,[],[]],[[-1,-2],8,[],[]],[21],[9,12],[[21,21],2],[[20,20],2],[[-1,-2],2,[],[]],[[-1,-2],2,[],[]],[9,[[0,[22]]]],[[21,13],14],[[20,13],14],[9,21],[-1,-1,[]],[-1,-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,12,[]],[21,12],[[-1,-3],[[0,[22]]],23,3,[[11,[[1,[-2]]]]]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,18,[]],[-1,18,[]],[-1,12,[]],[21,12],[-1,12,[]],[21,12],[[[24,[-1]],-2],[[16,[[24,[-1]]]]],25,26],[[[24,[-1]],-2],[[16,[[24,[-1]]]]],25,26]],"c":[],"p":[[3,"Options",0],[15,"bool"],[8,"WordSplitter",0],[3,"NoHyphenation",0],[3,"HyphenSplitter",0],[8,"Clone",110],[8,"Sized",111],[15,"tuple"],[15,"str"],[3,"String",112],[8,"Into",113],[15,"usize"],[3,"Formatter",114],[6,"Result",114],[8,"Debug",114],[3,"Vec",115],[4,"Result",116],[3,"TypeId",117],[4,"Cow",118],[4,"WrapAlgorithm",64],[3,"Word",64],[8,"Iterator",119],[8,"IntoIterator",120],[15,"slice"],[8,"Fragment",64],[8,"Fn",121]]},\
"unicode_width":{"doc":"Determine displayed width of <code>char</code> and <code>str</code> types according …","t":"RIIKKKK","n":["UNICODE_VERSION","UnicodeWidthChar","UnicodeWidthStr","width","width","width_cjk","width_cjk"],"q":[[0,"unicode_width"],[7,"core::option"]],"d":["The version of Unicode that this version of unicode-width …","Methods for determining displayed width of Unicode …","Methods for determining displayed width of Unicode strings.","Returns the character’s displayed width in columns, or …","Returns the string’s displayed width in columns.","Returns the character’s displayed width in columns, or …","Returns the string’s displayed width in columns."],"i":[0,0,0,3,4,3,4],"f":[0,0,0,[-1,[[2,[1]]],[]],[-1,1,[]],[-1,[[2,[1]]],[]],[-1,1,[]]],"c":[],"p":[[15,"usize"],[4,"Option",7],[8,"UnicodeWidthChar",0],[8,"UnicodeWidthStr",0]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
